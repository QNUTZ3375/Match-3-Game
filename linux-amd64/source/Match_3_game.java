/* autogenerated by Processing revision 1293 on 2024-04-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Match_3_game extends PApplet {


int xStartPos = 300;
int yStartPos = -300;
int cellSize = 50;
int colLen = 7; //i = colLen
int rowLen = 9; //j = rowLen
Cell[][] board = new Cell[colLen][rowLen];
boolean hasClickedOnce = false;
int currX1, currY1, currX2, currY2 = 0; //Stores the first piece and second piece coordinates for selecting
boolean needsToClear = false; //checks if there is a piece to clear
boolean clearAllPieces = false; //checks if the entire board needs to be cleared due to double special piece swap
boolean needToSwapBack = false; //checks if the most recent swap didn't match anything
boolean isReshuffling = false; //checks if the reshuffling animation is currently happening
int shrinkLimit = cellSize * 3 / 10; //The shrink size limit is 30% of the cellSize for all shapes (designed to reduce complexity)
float shrinkRate = PApplet.parseFloat(cellSize) / 40;
Piece[][] result = {}; //stores the list of matches, usually should be empty
Piece[][] specialClears = {}; //stores the list of pieces that are cleared due to special pieces
String[] specialClearTypes = {}; //stores the types of special clears (paired with specialClears)
int[] piece1Disp = {0, 0};
int[] piece2Disp = {0, 0};
int positiveDisp = cellSize / 10;
int negativeDisp = -1 * positiveDisp; //negativeDisp has to have the same magnitude as positiveDisp
int[][] cellVertiDispsFromCenter = {}; //stores all vertical displacements of the cells from the center
int[][] cellHorizDispsFromCenter = {}; //stores all horizontal displacements of the cells from the center
int shuffleOrder = 1; //specifies the order of the shuffling animation 
//(1 = Towards center, 0 = actually swapping pieces, -1 = Away from center)
String shuffleDirection = "VERTICAL"; //specifies in which direction the pieces are to move during the animation
boolean currentlyShuffling = false; //checks if any piece is still moving
int prevID = -1; //holds the ID of the previous piece generated
int targetScore = -1;
int playerScore = -1;
int scoreIncrement = 100;
int moveCount = -1;
int currLevel = 1;
PFont f;
int resultingState = 0; //0 means nothing, 1 means passed level, -1 means failed level
int counterBeforeShuffle = 0;

public void generateNewLevel(int level){
  resetAllParameters();
  generateLevel(level);
  generateBoardAndPieces();
  generateHoles(level);

  result = checkBoardState();
  if (result.length > 0){
    result = checkSpecialMatches(result, false);
    needsToClear = true;
  }
  generateDispsFromCenter();
}

public void resetAllParameters(){
  hasClickedOnce = false;
  currX1 = currY1 = currX2 = currY2 = 0;
  needsToClear = false;
  needToSwapBack = false;
  isReshuffling = false;
  result = Arrays.copyOf(result, 0);
  piece1Disp[0] = piece1Disp[1] = 0;
  piece2Disp[0] = piece2Disp[1] = 0;
  cellVertiDispsFromCenter = Arrays.copyOf(cellVertiDispsFromCenter, 0);
  cellHorizDispsFromCenter = Arrays.copyOf(cellHorizDispsFromCenter, 0);
  shuffleOrder = 1;
  shuffleDirection = "VERTICAL"; 
  currentlyShuffling = false;
  droppingPieces = Arrays.copyOf(droppingPieces, 0);
  droppingDisps = Arrays.copyOf(droppingDisps, 0);
  needsToDrop = false;
  dropCounter = 0;
  swapCounter = 0;
  resultingState = 0;
}

public void addScores(int regular, int fireworks, int cross, int special){
  /*
  firework = 3x
  cross = 4x
  special = 5x
  */
  playerScore += regular * scoreIncrement;
  playerScore += fireworks * 3 * scoreIncrement;
  playerScore += cross * 4 * scoreIncrement;
  playerScore += special * 5 * scoreIncrement;
  
  println(regular, fireworks, cross, special);
}

public void reshufflePieces(){
  Cell[] allCells = {};
  //flattens the board cells into a one-dimensional array
  for(int i = 0; i < colLen; i++){
    for(int j = 2; j < rowLen; j++){
      //prevents empty or disabled pieces from being swapped
      if(board[i][j].currPiece.pieceID > 0){
        allCells = Arrays.copyOf(allCells, allCells.length + 1);
        allCells[allCells.length - 1] = board[i][j];
      }
    }
  }
  //swaps the last element with a random element excluding the last one then removes it (the last one) from the array, it keeps going until there's one element left
  for(int i = allCells.length - 1; i > 0; i--){
    int r = PApplet.parseInt(random(0, allCells.length - 2));
    allCells[i].swapPiece(false, allCells[r]);
    allCells = Arrays.copyOf(allCells, allCells.length - 1);
  }
}

public void setup(){
  //note: the window size should be in a 3:2 ratio
  /* size commented out by preprocessor */;
  rectMode(CENTER);
  f = createFont("AmericanTypewriter", 40, true);
  generateLevel(currLevel);
  generateBoardAndPieces();
  generateHoles(currLevel);
  
  result = checkBoardState();
  if (result.length > 0){
    result = checkSpecialMatches(result, false);
    needsToClear = true;
  }
  generateDispsFromCenter();
}

public void draw(){
  switch(resultingState){
    case 1:
      background(100, 255, 100);
      break;
    case -1:
      background(255, 100, 100);
      break;
    default:
      background(180);
  }
  //The two double-for loops deal with the visual bug where a piece slides under the grid 
  //when doing the swapping animation
  for(int i = 0; i < colLen; i++){
    for(int j = 0; j < rowLen; j++){
      board[i][j].show();
    }
  }
  for(int i = 0; i < colLen; i++){
    for(int j = 0; j < rowLen; j++){
      board[i][j].currPiece.show();
    }
  }
  switch(resultingState){
    case 1:
      fill(100, 255, 100);
      break;
    case -1:
      fill(255, 100, 100);
      break;
    default:
      fill(180);
  }
  //rectangle that hides the pieces above the playfield
  rect(width/2, yStartPos + cellSize, width, cellSize * 2);
  //left light blue rectangle
  fill(100, 230, 230);
  rect(175, height/2, 350, height);
  //text that shows metrics
  fill(0);
  textFont(f, 40);
  text("TARGET\nSCORE\nMOVES", 20, 70);
  text(":\n:\n:", 190, 67);
  text(targetScore + "\n" + playerScore + "\n" + moveCount, 210, 70);
  text("LEVEL", 98, 270);
  textFont(f, 80);
  text(currLevel, 140 - 20*(str(currLevel).length() - 1), 350);
  //draws line separating green and gray rectangles
  strokeWeight(3);
  stroke(0);
  line(350, 0, 350, height);
  //the next 2 lines are used to find the centerpoint of the playfield (used for calibration)
  //line(700, 0, 700, height);
  //line(350, 350, 1050, 350);
  noStroke();
  
  textFont(f, 40);
  if(isReshuffling){
    text("RESHUFFLING...", 365, height - 20);
  }
  
  textFont(f, 28);
  if(resultingState == 1){
    text("CONGRATULATIONS!\nPRESS ANY KEY\nFOR THE NEXT LEVEL", 20, 500);
  }
  if(resultingState == -1){
    text("PRESS ANY KEY\nTO RETRY", 20, 500);
  }
  
  if(swapCounter > 0){ //checks if there is a swap to be made
    swapCounter--;
    if(swapCounter <= 0){ //checks if the swap is done
      //resets all of the displacement variables and swaps the actual pieces at the end
      piece1Disp[0] = piece1Disp[1] = piece2Disp[0] = piece2Disp[1] = 0;
      board[currX1][currY1].swapPiece(true, board[currX2][currY2]);
      //Check swapped pieces
      result = checkSwappedPieces();
      if (result.length > 0){ //if there are matches to be cleared
        result = checkSpecialMatches(result, true);
        moveCount = max(0, --moveCount);
        needsToClear = true;
      } else{ //case where no matches are found after swapping
        needToSwapBack = !needToSwapBack; //switches the state of the boolean variable depending on how many times the pieces have swapped
      }
    }
    //updates the position of the two pieces 
    board[currX1][currY1].currPiece.changeDirection(piece1Disp[0], piece1Disp[1]);
    board[currX2][currY2].currPiece.changeDirection(piece2Disp[0], piece2Disp[1]);
  } else if(needToSwapBack){
    switchPieces(board[currX1][currY1].currPiece, board[currX2][currY2].currPiece); //swaps back the pieces if no matches are found
  } else if(needsToClear || clearAllPieces){    
    shrinkPieces(result[0]);
  } else if(needsToDrop){
    if(dropCounter > 0){
      dropCounter--;
      
      if(dropCounter <= 0){ //checks if the dropping is done
        while(droppingPieces.length > 0 && droppingDisps.length > 0){
          droppingPieces[0].currPiece.isDropping = false;
          board[droppingPieces[0].x + droppingDisps[0][0] / positiveDisp] //pt1
               [droppingPieces[0].y + droppingDisps[0][1] / positiveDisp].swapPiece(true, droppingPieces[0]); //pt2
          for(int i = 0; i < droppingPieces.length - 1; i++){
            droppingPieces[i] = droppingPieces[i + 1];
            droppingDisps[i] = droppingDisps[i + 1];
          }
          droppingPieces = Arrays.copyOf(droppingPieces, droppingPieces.length - 1);
          droppingDisps = Arrays.copyOf(droppingDisps, droppingDisps.length - 1);
        }
        dropPieces(); //finds the next set of pieces to drop
        fillEmptyCellsOutsidePlayField();
      }
      for(int i = 0; i < droppingPieces.length - 1; i++){ //drops all the pieces according to their directions
        droppingPieces[i].currPiece.changeDirection(droppingDisps[i][0], droppingDisps[i][1]);
      }
    }
  } else if(isReshuffling){
    //all animation starts with vertical motion, followed by horizontal motion
    switch(shuffleOrder){
      case 1: //towards center
        if(shuffleDirection == "VERTICAL"){
          //default case where no pieces moved
          currentlyShuffling = false;
          for(int i = 0; i < colLen; i++){
            for(int j = 2; j < rowLen; j++){
              //case where piece is above center point of playfield
              if(j <= (rowLen + 2)/2 && board[i][j].currPiece.yDisp < cellVertiDispsFromCenter[i][j - 2]){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(0, positiveDisp);
              //case where piece is below center point of playfield
              } else if (j >= (rowLen + 2)/2 && board[i][j].currPiece.yDisp > cellVertiDispsFromCenter[i][j - 2]){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(0, negativeDisp);
              }
            }
          }
          if(!currentlyShuffling){
            shuffleDirection = "HORIZONTAL";
          }
        } else if(shuffleDirection == "HORIZONTAL"){
          //default case where no pieces moved
          currentlyShuffling = false;
          for(int i = 0; i < colLen; i++){
            for(int j = 2; j < rowLen; j++){
              //case where piece is to the left of the center point of playfield
              if(i <= colLen/2 && board[i][j].currPiece.xDisp < cellHorizDispsFromCenter[i][j - 2]){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(positiveDisp, 0); 
              }
              //case where piece is to the right of the center point of playfield
              if(i >= colLen/2 && board[i][j].currPiece.xDisp > cellHorizDispsFromCenter[i][j - 2]){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(negativeDisp, 0); 
              }
            }
          }
          if(!currentlyShuffling){
            shuffleDirection = "VERTICAL";
            shuffleOrder = 0;
          }
        }
        break;
      case 0: //shuffles pieces (actually shuffles them now)
        reshufflePieces();
        shuffleOrder = -1; 
        break;
      case -1: //away from center
        if(shuffleDirection == "VERTICAL"){
          //default case where no pieces moved
          currentlyShuffling = false;
          for(int i = 0; i < colLen; i++){
            for(int j = 2; j < rowLen; j++){
              //case where piece should return to above center point of playfield
              if(j <= (rowLen + 2)/2 && board[i][j].currPiece.yDisp > 0){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(0, negativeDisp);
              //case where piece should return to below center point of playfield
              } else if (j >= (rowLen + 2)/2 && board[i][j].currPiece.yDisp < 0){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(0, positiveDisp);
              }
            }
          }
          if(!currentlyShuffling){
            shuffleDirection = "HORIZONTAL";
          }
        } else if(shuffleDirection == "HORIZONTAL"){
          //default case where no pieces moved
          currentlyShuffling = false;
          for(int i = 0; i < colLen; i++){
            for(int j = 2; j < rowLen; j++){
              //case where piece should return to the left of the center point of playfield
              if(i <= colLen/2 && board[i][j].currPiece.xDisp > 0){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(negativeDisp, 0); 
              }
              //case where piece is to the right of the center point of playfield
              if(i >= colLen/2 && board[i][j].currPiece.xDisp < 0){
                currentlyShuffling = true;
                board[i][j].currPiece.changeDirection(positiveDisp, 0); 
              }
            }
          }
          if(!currentlyShuffling){
            shuffleDirection = "VERTICAL";
            shuffleOrder = 1;
            isReshuffling = false;
          }
        }
        break;
    }
  }
  if(!needsToDrop && !needsToClear && swapCounter <= 0 && !isReshuffling && rowLen > 0 && colLen > 0){
    result = checkBoardState();
    if (result.length > 0){
      result = checkSpecialMatches(result, false);
      needsToClear = true;
    }else if(!checkValidSwitches(false)){
      if(counterBeforeShuffle >= 30){
        isReshuffling = true;
        counterBeforeShuffle = 0;
      } 
      else{
        counterBeforeShuffle++;
      }
    }else if(playerScore >= targetScore){
      resultingState = 1;
    }else if(moveCount <= 0 && playerScore < targetScore){
      resultingState = -1;
    }
  }
}

public void mousePressed(){
  //prevents mouse clicks if there are any actions being performed or if a level has been cleared or failed 
  if(swapCounter > 0 || needsToClear || needsToDrop || needToSwapBack || isReshuffling || moveCount <= 0 || resultingState != 0){
    return;
  }
  //prevents the mouse click from registering if it's outside of the play field
  if(mouseX <= xStartPos || mouseY <= yStartPos + 2*cellSize || mouseX >= xStartPos + colLen * cellSize || mouseY >= yStartPos + rowLen * cellSize){
    hasClickedOnce = false;
    board[currX2][currY2].clickOrder = 0;
    board[currX1][currY1].clickOrder = 0;
    return;
  }
  //case where player hasn't selected another piece yet
  if(!hasClickedOnce){
    board[currX1][currY1].clickOrder = 0;
    board[currX2][currY2].clickOrder = 0;
    currX1 = PApplet.parseInt((mouseX - xStartPos) / cellSize);
    currY1 = PApplet.parseInt((mouseY - yStartPos) / cellSize);
    if(board[currX1][currY1].hasPiece && board[currX1][currY1].currPiece.pieceID > 0){
      hasClickedOnce = true;
      board[currX1][currY1].clickOrder = 1;
    }
    return;
  }
  
  currX2 = PApplet.parseInt((mouseX - xStartPos) / cellSize);
  currY2 = PApplet.parseInt((mouseY - yStartPos) / cellSize);
  //resets the boolean variable if the piece being selected is disabled or is a border
  if(!board[currX2][currY2].hasPiece || board[currX2][currY2].currPiece.pieceID <= 0){
    hasClickedOnce = false;
    board[currX2][currY2].clickOrder = 0;
    board[currX1][currY1].clickOrder = 0;
    return;
  }

  int tempXDisp = abs(currX2 - currX1);
  int tempYDisp = abs(currY2 - currY1);
  //checks if the two pieces selected are directly adjacent to each other
  if ((tempXDisp == 1 && tempYDisp == 0) || (tempXDisp == 0 && tempYDisp == 1)){ 
    //checks if the two selected pieces are adjacent and if the cell has a piece in it
    hasClickedOnce = false;
    board[currX2][currY2].clickOrder = 2;
    switchPieces(board[currX1][currY1].currPiece, board[currX2][currY2].currPiece);
  } else{ //moves x2 and y2 into x1 and y1
    board[currX1][currY1].clickOrder = 0;
    board[currX2][currY2].clickOrder = 1;
    currX1 = currX2;
    currY1 = currY2;
  }
}

public void keyPressed(){
  if(resultingState != 0){
    if(resultingState == 1){
      currLevel++;
    }
    generateNewLevel(currLevel);
    return; //prevents special keys from triggering their blocks of code
  }
  if(48 <= (int) key && (int) key <= 57){
    currLevel = (int) key - 48;
    generateNewLevel(currLevel);
  }
  if(keyCode == LEFT && currLevel > 1){
    currLevel--;
    generateNewLevel(currLevel);
  }
  if(keyCode == RIGHT && currLevel < 9){
    currLevel++;
    generateNewLevel(currLevel);
  }
  if(key == 'h'){
    println(checkValidSwitches(true));
  }
  if(key == 's'){
    isReshuffling = true;
  }
}

/*
Notes:
- 28 Dec: made board and the pieces with colors, added mouse clicking recognition
- 29 Dec: added a piece swap function, fixed visual bug where the pieces weren't getting swapped correctly
- 29 Dec: added a conditional check that makes sure only adjacent pieces are allowed to swap (no diagonals)
- 29 Dec: added piece swapping animation, added a function to check the whole board for any consecutive matches
- 30 Dec: tweaked the check board function to only add elements to array if the element is at least 3 long
- 30 Dec: added a check to remove duplicate values in the check pieces function
- 30 Dec: added piece clearing animations for all pieces, checked if swapped pieces created any matches
- 31 Dec: tweaked the piece checking function so it can detect L-shaped, T-shaped, and Cross-shaped matches from one move
- 31 Dec: prevented empty cells from being selected and swapped with other cells
- 31 Dec: finished a working prototype of the dropPieces function
- 1 Jan: added support for checking piece matches after dropping pieces (some are still not registering)
- 1 Jan: attempted to check for larger matches

- 4 Jan: returned to this project. started working on a longDrop function. fixed a bug where pieces didn't want to drop all the way down
(switched hasPiece condition to hasCell condition in cell class for swapPiece function)
- 5 Jan: completed the longDropPieces function. fixed a lot of bugs along the way (arrays not being reset after use, multiple function calls etc)
- 5 Jan: added a function to fill all empty spots outside of play field, added a function to check if a valid swap is possible in a given board state
- 6 Jan: added a reshufflePieces function, set a condition so that the player can't make moves during reshuffling
- 6 Jan: added animation sequence for reshuffling pieces, tweaked the swapPiece function
- 7 Jan: prevented 3 of the same piece to spawn vertically at the same time, added a bar to hide the pieces outside the playfield
- 7 Jan: added scoring and move counting, added level concept (levels 1, 5)
- 8 Jan: refactored some code using guard clauses concept, added star piece and hexagon piece w/ shrink animation
- 8 Jan: added firework and cross graphics
- 9 Jan: added a function to check if a match creates any of the special pieces mentioned above
- 10 Jan: finished the function that checks if any special pieces were matched, and any subsequent matches after that
- 10 Jan: fixed a lot of bugs, including one where crosses wouldn't form properly due to duplicate values within
horizMatches, causing the cross piece to get erased too along with the other pieces
- 10 Jan: added sprites for each special piece that can be assigned to each piece within specialClears
- 10 Jan: swapped the hexagon and the star piece IDs, added multipliers for each special piece
- 10 Jan: added a clear board function on the rare case where two special pieces are swapped with each other

- 12 Jan: took a rest day, added progression, automated the shuffling and checkValidSwitches() condition
- 12 Jan: added X level, bomb level, and shield level (levels 2, 6, 7)
- 12 Jan: modified the generateLevels() function so now the x and y start positions are relative to colLen and rowLen
- 12 Jan: modified checkValidSwitches so now it only prints a valid switch when prompted, improved the resultingState
update so that it only checks after everything stops moving, added text and background changes according to resultingState
- 12 Jan: fixed a bug where dropPieces wouldn't register the top right diagonal cell as a droppable piece to use (control flow issue)
- 12 Jan: removed the longDrop function after discovering a bug that when fixed, allowed dropPieces to function just as fast as longDropPieces
modified dropPieces twice, one where the function starts inside the playfield instead of the very top (which fixed the control flow bug above)
and the other is where the function goes from bottom to top now instead of top to bottom, so that it prioritizes straight down drops first
- 12 Jan: changed the condition for rowLen, instead of making rowLen being twice the actual rows it now requires itself to be 2 + actual rows in playfield
- 12 Jan: added extra conditions within droppingPieces and a helper function to fix the priority of diagonal vs vertical dropping
- 12 Jan: added another check (an array) holesMade to work in conjunction with the helper function to fix the same issue
- 12 Jan: modified dropPieces to now check if the piece is empty and in the playfield when attempting diagonal movement 
(bug can be caused in bomb level with far left middle match, causing top left to diagonally accept top right)
- 13 Jan: (basically) overhauled the dropPieces function, added a helper function to check for holes within a continuous column section
- 13 Jan: added border checks (doesn't allow pieces outside playfield for diagonal movement), added checks using the helper function
- 13 Jan: fixed a lot of bugs over the course of the afternoon due to the faulty design of the old dropPieces function
- 14 Jan: reworked the user interface, refactored the mousePressed function, added H level, Xv2 level, hourglass level, tree level (levels 3, 4, 8, 9)
- 14 Jan: allowed modified pieces to be swapped regardless of pieceID.

THIS PROJECT IS CURRENTLY FINISHED AS OF NOW (Might add some more in the future), 2005 Lines of code
*/
class Cell {
  int x, y;
  Piece currPiece;
  int clickOrder = 0;
  boolean hasPiece = true;
  
  Cell(int _x, int _y, Piece curr){
    x = _x;
    y = _y;
    currPiece = curr;
  }
  
  public void disableCell(){
    hasPiece = false;
    currPiece.hasCell = false;
    currPiece.pieceID = -1;
  }
  
  public void show(){
    if(!hasPiece){
      return;
    }
    switch (clickOrder){
      case 1:
        fill(0, 150, 125);
        break;
      case 2:
        fill(125, 0, 0);
        break;
      default:
        fill(150);
    }
    strokeWeight(1);
    stroke(0);
    square(xStartPos + x * cellSize + cellSize / 2, yStartPos + y * cellSize + cellSize / 2, cellSize);
  }
  
  public void swapPiece(boolean resetDisp, Cell toSwap){
    if(!currPiece.hasCell || !toSwap.currPiece.hasCell){
      return;
    }
    //checks if the two pieces want their displacements to be reset 
    //(this is used to differentiate between the reshuffling sequence and everything else)
    if(resetDisp){
      currPiece.resetDisplacement();
      toSwap.currPiece.resetDisplacement();
    } else{ //otherwise swaps their displacements (for reshuffling)
      int tempXDisp = toSwap.currPiece.xDisp;
      int tempYDisp = toSwap.currPiece.yDisp;
      toSwap.currPiece.xDisp = currPiece.xDisp;
      toSwap.currPiece.yDisp = currPiece.yDisp;
      currPiece.xDisp = tempXDisp;
      currPiece.yDisp = tempYDisp;
    }
    
    //Note: swap the x, y, and reference of the pieces. 
    //Swapping the references ensures there are no coordinate errors
    //and swapping the x y values is necessary for the swapping animation to work
    
    //swapping references mean the cells now hold different pieces 
    //but both of the piece's original xy coordinates stay unchanged (so both cell's pieces are in the wrong positions)
    //swapping those xy coordinates afterwards fixes that issue
    int tempx = toSwap.currPiece.x;
    int tempy = toSwap.currPiece.y;
    Piece ref = toSwap.currPiece;
    toSwap.currPiece.x = currPiece.x;
    toSwap.currPiece.y = currPiece.y;
    toSwap.currPiece = currPiece;
    currPiece.x = tempx;
    currPiece.y = tempy;
    currPiece = ref;
  }
  
  public boolean isSwappableOnPlayField(){
    return hasPiece && currPiece.pieceID > 0 && currPiece.hasCell;
  }
}
class Piece {
  int x, y;
  int pieceID;
  int xDisp, yDisp = 0;
  int fireworkPos = 0; //0 means nothing, 1 is vertical, 2 is horizontal, 3 is left diagonal, 4 is right diagonal
  int crossPos = 0; //0 means nothing, 1 is vertical, 2 is horizontal
  int specialVal = 0; //0 means nothing, 1 means present
  boolean hasCell = true;
  boolean isDropping = false;
  boolean hasFirework = false;
  boolean hasCross = false;
  boolean isSpecialPiece = false;
  float shrinkSize = 0; //size reduction of shape
  //Table for shrink size limits:
  //Square: 30
  //Circle: 30
  //Triangle: 30
  //Diamond: 30
  //Line: 20
  
  Piece(int _x, int _y, int temp){
    x = _x;
    y = _y;
    pieceID = temp;
  }
  
  public boolean isModifiedPiece(){
    return hasFirework || hasCross || isSpecialPiece;
  }
  
  public void changeDirection(int tempX, int tempY){
    xDisp += tempX;
    yDisp += tempY;
  }
  
  public void resetDisplacement(){
    xDisp = yDisp = 0;
  }
  
  public void show(){
    if(!hasCell){
      return;
    }
        
    int defaultX = xStartPos + x * cellSize + xDisp;
    int defaultY = yStartPos + y * cellSize + yDisp;
    if(hasFirework){
      strokeWeight(2);
      stroke(255, 0, 0);
      line(defaultX + cellSize / 2, defaultY + cellSize * 1/10, defaultX + cellSize / 2, defaultY + cellSize * 9/10);
      stroke(255, 125, 0);
      line(defaultX + cellSize * 1/10, defaultY + cellSize / 2, defaultX + cellSize * 9/10, defaultY + cellSize / 2);
      stroke(255, 255, 0);
      line(defaultX + cellSize * 1/10, defaultY + cellSize * 1/10, defaultX + cellSize * 9/10, defaultY + cellSize * 9/10);
      stroke(125, 255, 0);
      line(defaultX + cellSize * 1/10, defaultY + cellSize * 9/10, defaultX + cellSize * 9/10, defaultY + cellSize * 1/10);
    }
    noStroke();

    if(hasCross){
      fill(255);
      rect(defaultX + cellSize / 2, defaultY + cellSize / 2, cellSize * 1/5, cellSize * 4/5);
      rect(defaultX + cellSize / 2, defaultY + cellSize / 2, cellSize * 4/5, cellSize * 1/5);
    }
    
    if(isSpecialPiece){ //special (star) piece
      int len = cellSize * 3/10 - PApplet.parseInt(shrinkSize); //length of a point of the star to the center
      /*
      length = len
      center = x, y
      top = x, y - len
      bottom left = x - len * sin(36), y + len * sin(54)
      bottom right = x + len * sin(36), y + len * sin(54)
      top left = x - len * sin(72), y - len * sin(18)
      top right = x + len * sin(72), y - len * sin(18)
      */
      fill(255);
      beginShape();
      vertex(defaultX + cellSize / 2, defaultY + cellSize / 2 - len + len * shrinkSize/shrinkLimit); //Top
      vertex(defaultX + cellSize / 2 - len * sin(radians(36)), defaultY + cellSize / 2 + len * sin(radians(54))); //Bottom left
      vertex(defaultX + cellSize / 2 + len * sin(radians(72)), defaultY + cellSize / 2 - len * sin(radians(18))); //Right
      vertex(defaultX + cellSize / 2 - len * sin(radians(72)), defaultY + cellSize / 2 - len * sin(radians(18))); //Left
      vertex(defaultX + cellSize / 2 + len * sin(radians(36)), defaultY + cellSize / 2 + len * sin(radians(54))); //Bottom right
      endShape(CLOSE);
      return;
    }
    
    fill(255, 255, 255, 150);
    if(specialVal == 1){
      square(defaultX + cellSize/2, defaultY + cellSize/2, cellSize - 4 * shrinkSize);
    }
    
    switch (pieceID){
      //Square piece
      case 1:
        fill(255, 0, 0);
        square(defaultX + cellSize / 2, defaultY + cellSize / 2, max(0, cellSize / 2 - 2 * shrinkSize));
        break;
      //Triangle piece
      case 2:
        fill(0, 255, 0);
        triangle(defaultX + cellSize / 2, defaultY + cellSize * 1/5 + shrinkSize,    //Top
                 defaultX + cellSize * 1/5 + shrinkSize, defaultY + cellSize * 4/5 - shrinkSize,  //Left
                 defaultX + cellSize * 4/5 - shrinkSize, defaultY + cellSize * 4/5 - shrinkSize); //Right
        break;
      //Line Piece
      case 3:
        fill(0, 0, 255);
        rect(defaultX + cellSize / 2, defaultY + cellSize / 2, 
             cellSize * 3/4 - 75.0f * (shrinkSize/30.0f), cellSize * 1/5 - 20.0f * (shrinkSize/30.0f)); //75, 20
        break;
      //Circle Piece
      case 4:
        fill(255, 255, 0);
        circle(defaultX + cellSize / 2, defaultY + cellSize / 2, cellSize * 3/5 - 2 * shrinkSize);
        break;
      //Diamond piece
      case 5:
        fill(255, 125, 0);
        quad(defaultX + cellSize * 1/2, defaultY + cellSize * 1/5 + shrinkSize,  //Top
             defaultX + cellSize * 4/5 - shrinkSize, defaultY + cellSize * 1/2,  //Right
             defaultX + cellSize * 1/2, defaultY + cellSize * 4/5 - shrinkSize,  //Bottom
             defaultX + cellSize * 1/5 + shrinkSize, defaultY + cellSize * 1/2); //Left
        break;
      //Hexagon piece
      case 6:
        int radius = cellSize * 3/10 - PApplet.parseInt(shrinkSize); //cellSize * 0.5 - cellSize * 0.2 = cellSize * 0.3
        fill(240, 0, 240);
        beginShape();
        vertex(defaultX + cellSize / 2, defaultY + cellSize / 2 - radius); //Top
        vertex(defaultX + cellSize / 2 - radius * sin(radians(60)), defaultY + cellSize/2 - radius * cos(radians(60))); //Top left
        vertex(defaultX + cellSize / 2 - radius * sin(radians(60)), defaultY + cellSize/2 + radius * cos(radians(60))); //Bottom left
        vertex(defaultX + cellSize / 2, defaultY + cellSize / 2 + radius); //Bottom
        vertex(defaultX + cellSize / 2 + radius * sin(radians(60)), defaultY + cellSize/2 + radius * cos(radians(60))); //Bottom right
        vertex(defaultX + cellSize / 2 + radius * sin(radians(60)), defaultY + cellSize/2 - radius * cos(radians(60))); //Top right
        endShape(CLOSE);
        break;
      //Empty piece
      default:
    }
    
    strokeWeight(4);
    switch(fireworkPos){
      case 1:
        stroke(255, 0, 0);
        line(defaultX + cellSize / 2, defaultY, defaultX + cellSize / 2, defaultY + cellSize);
        break;
      case 2:
        stroke(255, 125, 0);
        line(defaultX, defaultY + cellSize / 2, defaultX + cellSize, defaultY + cellSize / 2);
         break;
      case 3:
        stroke(255, 255, 0);
        line(defaultX, defaultY, defaultX + cellSize, defaultY + cellSize);
        break;
      case 4:
        stroke(125, 255, 0);
        line(defaultX, defaultY + cellSize, defaultX + cellSize, defaultY);
        break;
      default:
    }
    noStroke();
    
    fill(255);
    switch(crossPos){
      case 1:
        rect(defaultX + cellSize / 2, defaultY + cellSize / 2, cellSize, cellSize * 1/5);
        break;
      case 2:
        rect(defaultX + cellSize / 2, defaultY + cellSize / 2, cellSize * 1/5, cellSize);
        break;
      default:
    }
  }
}
public Piece[] checkPiece(int xPos, int yPos, int prevID, String direction, Piece[] matches, int[][] visited){
  /*
  basically a graph traversal algorithm using DFS to check for matches of length 3 or longer given a current piece.
  */
  for(int i = 0; i < visited.length; i++){
    if (xPos == visited[i][0] && yPos == visited[i][1]){ //case where piece has been explored before
      return matches;
    }
  }
  //Adds current piece to visited
  visited = Arrays.copyOf(visited, visited.length + 1);
  visited[visited.length - 1] = new int[2];
  visited[visited.length - 1][0] = xPos;
  visited[visited.length - 1][1] = yPos;
  
  if (board[xPos][yPos].currPiece.pieceID != prevID){
    return matches;
  } //checks if the piece does not have the same ID as the previous piece

  matches = Arrays.copyOf(matches, matches.length + 1);  
  matches[matches.length - 1] = board[xPos][yPos].currPiece;
  //only check the neighbors if the current piece matches the previous one
  //Note: it only considers cells that have their hasPiece value set to true (included in play field)
  if(direction == "HORIZONTAL"){
    if(xPos > 0){
      if(board[xPos - 1][yPos].hasPiece){
        matches = checkPiece(xPos - 1, yPos, board[xPos][yPos].currPiece.pieceID, "HORIZONTAL", matches, visited);
      }
    }
    if(xPos < colLen - 1){
      if(board[xPos + 1][yPos].hasPiece){
        matches = checkPiece(xPos + 1, yPos, board[xPos][yPos].currPiece.pieceID, "HORIZONTAL", matches, visited);
      }
    }
  } else if (direction == "VERTICAL"){
    if(yPos > 2){
      if(board[xPos][yPos - 1].hasPiece){
        matches = checkPiece(xPos, yPos - 1, board[xPos][yPos].currPiece.pieceID, "VERTICAL", matches, visited);
      }
    }
    if(yPos < rowLen - 1){
      if(board[xPos][yPos + 1].hasPiece){
        matches = checkPiece(xPos, yPos + 1, board[xPos][yPos].currPiece.pieceID, "VERTICAL", matches, visited);
      }
    }
  }
  return matches;
}

public Piece[][] checkBoardState(){
  /*
  go through every cell in the playfield. check in all four directions if there are any matches of length 3 or longer.
  record those matches in vertiMatches and horizMatches.
  */
  Piece[][] vertiMatches = {};
  Piece[][] horizMatches = {};
  for(int i = 0; i < colLen; i++){
    for(int j = 2; j < rowLen; j++){
      if(!board[i][j].hasPiece){
        continue;
      }
      int[][] visited1 = {};
      int[][] visited2 = {};

      Piece[] temp1 = {};
      Piece[] temp2 = {};
      temp1 = checkPiece(i, j, board[i][j].currPiece.pieceID, "VERTICAL", temp1, visited1);
      if (temp1.length >= 3){
        boolean isIncluded = false;
        for(int idx = 0; idx < vertiMatches.length; idx++){ //removes duplicate vertical values
          if (vertiMatches[idx][0].pieceID == temp1[0].pieceID && vertiMatches[idx][0].x == temp1[0].x){
            isIncluded = true;
            break;
          }
        }
        if(!isIncluded){
          vertiMatches = Arrays.copyOf(vertiMatches, vertiMatches.length + 1);
          vertiMatches[vertiMatches.length - 1] = temp1;
        }
      }
      temp2 = checkPiece(i, j, board[i][j].currPiece.pieceID, "HORIZONTAL", temp2, visited2);
      if(temp2.length >= 3){
        boolean isIncluded = false;
        for(int idx = 0; idx < horizMatches.length; idx++){ //removes duplicate horizontal values
          if (horizMatches[idx][0].pieceID == temp1[0].pieceID && horizMatches[idx][0].y == temp1[0].y){
            isIncluded = true;
            break;
          }
        }
        if(!isIncluded){
          horizMatches = Arrays.copyOf(horizMatches, horizMatches.length + 1);
          horizMatches[horizMatches.length - 1] = temp2;
        }
      }
      if(horizMatches.length > 0 && vertiMatches.length > 0){ //checks if both arrays are non-empty
        for(int k = 0; k < horizMatches[horizMatches.length - 1].length; k++){
          boolean foundIntersect = false;
          for(int l = 0; l < vertiMatches[vertiMatches.length - 1].length; l++){
            if(horizMatches[horizMatches.length - 1][k] == vertiMatches[vertiMatches.length - 1][l]){ //Checks if a piece has made both a vertical and horizontal match
              foundIntersect = true;
              for(int idx = 0; idx < vertiMatches[vertiMatches.length - 1].length; idx++){ //appends the vertical result to the horizontal array
                if(idx != l){
                  horizMatches[horizMatches.length - 1] = Arrays.copyOf(horizMatches[horizMatches.length - 1], horizMatches[horizMatches.length - 1].length + 1);
                  horizMatches[horizMatches.length - 1][horizMatches[horizMatches.length - 1].length - 1] = vertiMatches[vertiMatches.length - 1][idx];
                }
              }
            }
          }
          if(foundIntersect){
            //deletes the record from vertiMatches to preven duplicate entries in result (important for checkSpecialMatches function to work)
            vertiMatches = Arrays.copyOf(vertiMatches, vertiMatches.length - 1);
            break;
          }
        }
        //removes duplicates within a single element of horizMatches
        Piece[] checkDupes = {};
        for(int idx = 0; idx < horizMatches[horizMatches.length - 1].length; idx++){
          boolean isIn = false;
          for(int idx2 = 0; idx2 < checkDupes.length; idx2++){
            if(checkDupes[idx2] == horizMatches[horizMatches.length - 1][idx]){
              isIn = true;
            }
          }
          if(!isIn){
            checkDupes = Arrays.copyOf(checkDupes, checkDupes.length + 1);
            checkDupes[checkDupes.length - 1] = horizMatches[horizMatches.length - 1][idx];
          }
        }
        horizMatches[horizMatches.length - 1] = checkDupes;
      }
    }
  }
  for (int i = 0; i < horizMatches.length; i++){
    for (int j = 0; j < horizMatches[i].length; j++){
      println("H", horizMatches[i][j].x, horizMatches[i][j].y, horizMatches[i][j].pieceID);
    }
    println();
  }
  
  for (int i = 0; i < vertiMatches.length; i++){
    for (int j = 0; j < vertiMatches[i].length; j++){
      println("V", vertiMatches[i][j].x, vertiMatches[i][j].y, vertiMatches[i][j].pieceID);
    }
    println();
  }
  Piece[][] ret = {}; //combines both vertical and horizontal matches into one array
  for(int i = 0; i < vertiMatches.length; i++){
    ret = Arrays.copyOf(ret, ret.length + 1);
    ret[ret.length - 1] = vertiMatches[i];
  }
  for(int i = 0; i < horizMatches.length; i++){
    ret = Arrays.copyOf(ret, ret.length + 1);
    ret[ret.length - 1] = horizMatches[i];
  }
  return ret;
}

public boolean checkValidSwitches(boolean shouldPrint){
  /*
  go through whole board in playfield. check all 4 directions (only length 3 because it's the bare minimum).
  if any direction contains three in a row, return true preemptively 
  (shouldn't ever happen normally due to checkBoardState).
  if any direction contains two of the same ID (including root piece), perform subroutine below. 
  if neither condition is true, then just continue to next piece. 
  if subroutine returns True then return true, else continue. 
  if it reaches the end without returning true once, return false.
  
  subroutine: 
  perform the check on the odd one out. check if any of the four directions (excluding the two pieces from above)
  contains another piece of the same ID as the two above. return True if found. return False otherwise.
  */
  for(int i = 0; i < colLen; i++){
    for(int j = 2; j < rowLen; j++){
      if(board[i][j].currPiece.isSpecialPiece){
        if(shouldPrint){
          println("X: ", i, "Y: ", j - 2, "SPECIAL PIECE PRESENT");
        }
        return true;
      }
      //check current piece in all 4 directions (do it one by one to prevent bugs with disabled pieces and borders)
      int currID = board[i][j].currPiece.pieceID;
      int[] oddOneOutPos = new int[2];
      if (j >= 2){ //check upwards
        //checks if both pieces above the current one are not disabled and are in playfield
        if(board[i][j - 1].isSwappableOnPlayField() && board[i][j - 2].isSwappableOnPlayField()){
          int upMatches = 1;
          if(board[i][j - 1].currPiece.pieceID == currID){
            upMatches++;
            oddOneOutPos[0] = i;
            oddOneOutPos[1] = j - 2;
          }
          if(board[i][j - 2].currPiece.pieceID == currID){
            upMatches++;
            oddOneOutPos[0] = i;
            oddOneOutPos[1] = j - 1;
          }
          if (upMatches == 3){
            if(shouldPrint){
              println("X: ", i, "Y: ", j - 2, "\nUP 3");
            }
            return true;
          } else if(upMatches == 2){
            //check left neighbor (if piece is not on first column)
            if(oddOneOutPos[0] > 0){
              if(board[oddOneOutPos[0] - 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nUP, neighbor on Left");
                }
                return true;
              }
            }
            //check right neighbor (if piece is not on last column)
            if(oddOneOutPos[0] < colLen - 1){
              if(board[oddOneOutPos[0] + 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nUP, neighbor on Right");
                }
                return true;
              }
            }
            //check top neighbor (if odd one out is the edge (not the center) and edge is not on first row (of playfield))
            if(oddOneOutPos[1] == j - 2 && oddOneOutPos[1] > 2){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] - 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nUP, neighbor on Up");
                }
                return true;
              }
            }
          }
        }
      }
      if (j <= rowLen - 3){ //check downwards
        //checks if both pieces above the current one are not disabled and are in playfield
        if(board[i][j + 1].isSwappableOnPlayField() && board[i][j + 2].isSwappableOnPlayField()){
          int downMatches = 1;
          if(board[i][j + 1].currPiece.pieceID == currID){
            downMatches++;
            oddOneOutPos[0] = i;
            oddOneOutPos[1] = j + 2;
          }
          if(board[i][j + 2].currPiece.pieceID == currID){
            downMatches++;
            oddOneOutPos[0] = i;
            oddOneOutPos[1] = j + 1;
          }
          if (downMatches == 3){
            if(shouldPrint){
              println("X: ", i, "Y: ", j - 2, "\nDOWN 3");
            }
            return true;
          } else if(downMatches == 2){
            //check left neighbor (if piece is not on first column)
            if(oddOneOutPos[0] > 0){
              if(board[oddOneOutPos[0] - 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nDOWN, neighbor on Left");
                }
                return true;
              }
            }
            //check right neighbor (if piece is not on last column)
            if(oddOneOutPos[0] < colLen - 1){
              if(board[oddOneOutPos[0] + 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nDOWN, neighbor on Right");
                }
                return true;
              }
            }
            //check bottom neighbor (if odd one out is the edge (not the center) and edge is not on last row)
            if(oddOneOutPos[1] == j + 2 && oddOneOutPos[1] < rowLen - 1){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] + 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nDOWN, neighbor on Bottom");
                }
                return true;
              }
            }
          }
        }
      }
      if (i >= 2){ //check leftwards
        //checks if both pieces left of the current one are not disabled and are in playfield
        if(board[i - 1][j].isSwappableOnPlayField() && board[i - 2][j].isSwappableOnPlayField()){
          int leftMatches = 1;
          if(board[i - 1][j].currPiece.pieceID == currID){
            leftMatches++;
            oddOneOutPos[0] = i - 2;
            oddOneOutPos[1] = j;
          }
          if(board[i - 2][j].currPiece.pieceID == currID){
            leftMatches++;
            oddOneOutPos[0] = i - 1;
            oddOneOutPos[1] = j;
          }
          if (leftMatches == 3){
            if(shouldPrint){
              println("X: ", i, "Y: ", j - 2, "\nLEFT 3");
            }
            return true;
          } else if(leftMatches == 2){
            //check top neighbor (if piece is not on first row (of playfield))
            if(oddOneOutPos[1] > 2){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] - 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nLEFT, neighbor on Up");
                }
                return true;
              }
            }
            //check bottom neighbor (if piece is not on last row)
            if(oddOneOutPos[1] < rowLen - 1){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] + 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nLEFT, neighbor on Bottom");
                }
                return true;
              }
            }
            //check left neighbor if odd one out is the edge (not the center) and edge is not on first column
            if(oddOneOutPos[0] == i - 2 && oddOneOutPos[0] > 0){
              if(board[oddOneOutPos[0] - 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nLEFT, neighbor on Left");
                }
                return true;
              }
            }
          }
        }
      }
      if (i <= colLen - 3){ //check rightwards
        //checks if both pieces right of the current one are not disabled and are in playfield
        if(board[i + 1][j].isSwappableOnPlayField() && board[i + 2][j].isSwappableOnPlayField()){
          int rightMatches = 1;
          if(board[i + 1][j].currPiece.pieceID == currID){
            rightMatches++;
            oddOneOutPos[0] = i + 2;
            oddOneOutPos[1] = j;
          }
          if(board[i + 2][j].currPiece.pieceID == currID){
            rightMatches++;
            oddOneOutPos[0] = i + 1;
            oddOneOutPos[1] = j;
          }
          if (rightMatches == 3){
            if(shouldPrint){
              println("X: ", i, "Y: ", j - 2, "\nRIGHT 3");
            }
            return true;
          } else if(rightMatches == 2){
            //check top neighbor (if piece is not on first row (of playfield))
            if(oddOneOutPos[1] > 2){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] - 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nRIGHT, neighbor on Up");
                }
                return true;
              }
            }
            //check bottom neighbor (if piece is not on last row)
            if(oddOneOutPos[1] < rowLen - 1){
              if(board[oddOneOutPos[0]][oddOneOutPos[1] + 1].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nRIGHT, neighbor on Bottom");
                }
                return true;
              }
            }
            //check right neighbor if odd one out is the edge (not the center) and edge is not on last column
            if(oddOneOutPos[0] == i + 2 && oddOneOutPos[0] < colLen - 1){
              if(board[oddOneOutPos[0] + 1][oddOneOutPos[1]].currPiece.pieceID == currID){
                if(shouldPrint){
                  println("X: ", i, "Y: ", j - 2, "\nRIGHT, neighbor on Right");
                }
                return true;
              }
            }
          }
        }
      }
    }
  }
  if(shouldPrint){
    println("Nope, no valid swaps");
  }
  return false;
}

public Piece[][] checkSpecialMatches(Piece[][] result, boolean useRecentVals){
  /*
  checks if any element in result is longer than 3. If it's 4, check the recent value. if true, use the recent values 
  currX1 Y1 X2 and Y2.
  
  else, randomly pick the center left or center right.
  
  If it's 5, check if either the column or row stays the same throughout the entire sub-array. 
  if yes, always choose the center.
  if not, use the majority voting algorithm to find the intersection.
  
  if the result is longer than 3, remove the piece chosen from the result array (to prevent clearing it).
  */
  int regular = 0;
  int fireworks = 0;
  int cross = 0;
  int special = 0;
  
  //loops through all elements in result
  for(int i = 0; i < result.length; i++){
    boolean hasSpecialMatch = false;
    //checks if any piece within result[i] is special
    for(int j = 0; j < result[i].length; j++){
      if (result[i][j].hasFirework){
        updateSpecialClears(result[i][j], "FIREWORK");
        hasSpecialMatch = true;
        fireworks++;
        regular--;
      }
      if(result[i][j].hasCross){
        updateSpecialClears(result[i][j], "CROSS");
        hasSpecialMatch = true;
        cross++;
        regular--;
      }
      if(result[i][j].isSpecialPiece){
        updateSpecialClears(result[i][(j + 1) % 2], "SPECIAL");
        result[i][j].isSpecialPiece = false;
        //appends the special piece to specialClears
        specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
        specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = result[i][j];
        hasSpecialMatch = true;
        special++;
        regular--;
      }
    }
    regular += result[i].length;
    //case where a special match has been made (ignores special cases)
    if(hasSpecialMatch){
      continue;
    }
    if(result[i].length == 4){
      //checks the most recent swapped pieces
      if(useRecentVals){
        //checks if currX1Y1 and currX2Y2 are in result[i]
        for(int j = 0; j < result[i].length; j++){
          if (result[i][j].x == currX1 && result[i][j].y == currY1){
            result[i][j].hasFirework = true;
          }
          if (result[i][j].x == currX2 && result[i][j].y == currY2){
            result[i][j].hasFirework = true;
          }
          if(result[i][j].hasFirework){
            //removes the current piece from the result[i] array (to prevent it from getting cleared) and exits loop early
            for(int k = j; k < result[i].length - 1; k++){
              result[i][k] = result[i][k + 1];
            }
            result[i] = Arrays.copyOf(result[i], result[i].length - 1);
            break;
          }
        }
      } else{
        //picks a random central value within result[i]
        int r = PApplet.parseInt(random(1, 3));
        result[i][r].hasFirework = true;
        //removes the current piece from the result[i] array (to prevent it from getting cleared)
        for(int k = r; k < result[i].length - 1; k++){
          result[i][k] = result[i][k + 1];
        }
        result[i] = Arrays.copyOf(result[i], result[i].length - 1);
      }
    } else if(result[i].length >= 5){
      int currRow = result[i][0].x;
      int currRowOccurences = 1;
      int currCol = result[i][0].y;
      int currColOccurences = 1;
      boolean changedRows = false;
      boolean changedCols = false;
      for(int j = 0; j < result[i].length; j++){
        //check whether the row has changed within result[i]
        if (currRow != result[i][j].x){
          changedRows = true;
          currRowOccurences--;
          if (currRowOccurences <= 0){
            currRow = result[i][j].x;
            currRowOccurences = 1;
          }
        } else{
          currRowOccurences++;
        }
        //check whether the column has changed within result[i]
        if (currCol != result[i][j].y){
          changedCols = true;
          currColOccurences--;
          if (currColOccurences <= 0){
            currCol = result[i][j].y;
            currColOccurences = 1;
          }
        } else{
          currColOccurences++;
        }
      }
      //case where both rows and cols changed (has an intersection), make a cross behind piece
      if(changedCols && changedRows){
        for(int k = 0; k < result[i].length; k++){
          if(result[i][k].x == currRow && result[i][k].y == currCol){
            result[i][k].hasCross = true;
            //removes the current piece from the result[i] array (to prevent it from getting cleared) and exits loop early
            for(int l = k; l < result[i].length - 1; l++){
              result[i][l] = result[i][l + 1];
            }
            result[i] = Arrays.copyOf(result[i], result[i].length - 1);
            break;
          }
        }
        break;
      } else{
        //case where 5 in a row (or longer) is found, making a special piece
        int rowToPick = 0;
        int colToPick = 0;
        //finds the column and row needed to make the special piece (always the center)
        //the reason being the results from checkSwappedPieces and checkBoardState return different array configurations, 
        //forcing the program to find it manually everytime
        for(int m = 0; m < result[i].length; m++){
          rowToPick += result[i][m].x;
          colToPick += result[i][m].y;
        }
        //finds the average of the rows and columns
        rowToPick /= result[i].length;
        colToPick /= result[i].length;
        for(int m = 0; m < result[i].length; m++){
          if(result[i][m].x == rowToPick && result[i][m].y == colToPick){
            result[i][m].isSpecialPiece = true;
            result[i][m].pieceID = 7;
            //removes the current piece from the result[i] array (to prevent it from getting cleared) and exits loop early
            for(int k = m; k < result[i].length - 1; k++){
              result[i][k] = result[i][k + 1];
            }
            result[i] = Arrays.copyOf(result[i], result[i].length - 1);
            break;
          }
        }
      }
    }
  }
  //keeps going through specialClears until it's empty
  while(specialClears.length > 0){
    //checks the first element of specialClears if there are any special pieces within those pieces
    for(int i = 0; i < specialClears[0].length; i++){
      //if any of the three are triggered, reduce the regular pieces by one and add special piece by one
      if(specialClears[0][i].hasFirework){
        updateSpecialClears(specialClears[0][i], "FIREWORK");
        fireworks++;
        regular--;
      }
      if(specialClears[0][i].hasCross){
        updateSpecialClears(specialClears[0][i], "CROSS");
        cross++;
        regular--;
      }
      if(specialClears[0][i].isSpecialPiece){
        updateSpecialClears(specialClears[0][i], "SPECIAL");
        special++;
        regular--;
      }
    }
    //counts the pieces in specialClears[0]
    regular += specialClears[0].length;
    
    //appends the first element of specialClears into result
    result = Arrays.copyOf(result, result.length + 1);
    result[result.length - 1] = new Piece[specialClears[0].length];
    for(int i = 0; i < specialClears[0].length; i++){
      result[result.length - 1][i] = specialClears[0][i];
    }
    
    //deletes the first element of speciaClears and specialClearTypes so that eventually specialClears becomes empty
    for(int i = 0; i < specialClears.length - 1; i++){
      specialClears[i] = specialClears[i + 1];
      specialClearTypes[i] = specialClearTypes[i + 1];
    }
    specialClears = Arrays.copyOf(specialClears, specialClears.length - 1);
    specialClearTypes = Arrays.copyOf(specialClearTypes, specialClearTypes.length - 1);
  }
  //tallies up the scores
  addScores(regular, fireworks, cross, special);
  return result;
}
public void updateSpecialClears(Piece currPiece, String type){
  specialClears = Arrays.copyOf(specialClears, specialClears.length + 1);
  specialClears[specialClears.length - 1] = new Piece[0];
  
  specialClearTypes = Arrays.copyOf(specialClearTypes, specialClearTypes.length + 1);
  specialClearTypes[specialClearTypes.length - 1] = type;

  if (type == "FIREWORK"){
    int[][] tempXYVals = {{currPiece.x - 1, currPiece.y - 1}, {currPiece.x, currPiece.y - 1}, {currPiece.x + 1, currPiece.y - 1},
                          {currPiece.x - 1, currPiece.y}    , {currPiece.x + 1, currPiece.y},
                          {currPiece.x - 1, currPiece.y + 1}, {currPiece.x, currPiece.y + 1}, {currPiece.x + 1, currPiece.y + 1}};
    int[] directions = {3, 1, 4, 2, 2, 4, 1, 3};
                          
    for(int i = 0; i < tempXYVals.length; i++){
      //checks if the xy coordinates are in bounds
      if (tempXYVals[i][0] >= 0 && tempXYVals[i][0] <= colLen - 1 && tempXYVals[i][1] >= 2 && tempXYVals[i][1] <= rowLen - 1){
        //checks if the current piece isn't empty or disabled
        if(board[tempXYVals[i][0]][tempXYVals[i][1]].currPiece.pieceID > 0){
          //appends the piece to specialClears
          specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
          specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = board[tempXYVals[i][0]][tempXYVals[i][1]].currPiece;
          board[tempXYVals[i][0]][tempXYVals[i][1]].currPiece.fireworkPos = directions[i];
        }
      }
    }
  } else if (type == "CROSS"){
    //adds all pieces in the same column as the piece (excluding the piece itself)
    for(int i = 0; i < colLen; i++){
      if(board[i][currPiece.y].currPiece.pieceID > 0 && i != currPiece.x){
        //appends the piece to specialClears
        specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
        specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = board[i][currPiece.y].currPiece;
        board[i][currPiece.y].currPiece.crossPos = 1;
      }
    }
    //adds all pieces in the same row as the piece (excluding the piece itself)
    for(int j = 2; j < rowLen; j++){
      if(board[currPiece.x][j].currPiece.pieceID > 0 && j != currPiece.y){
        //appends the piece to specialClears
        specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
        specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = board[currPiece.x][j].currPiece;
        board[currPiece.x][j].currPiece.crossPos = 2;
      }
    }
  } else if (type == "SPECIAL"){
    //appends all the pieces in the board with the same id as the current piece
    for(int i = 0; i < colLen; i++){
      for(int j = 2; j < rowLen; j++){
        if(board[i][j].currPiece.pieceID == currPiece.pieceID && board[i][j].currPiece != currPiece){
          //appends the piece to specialClears
          specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
          specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = board[i][j].currPiece;
          board[i][j].currPiece.specialVal = 1;
        }
      }
    }
  }
  //resets all of the current piece attributes and appends it to specialClears
  currPiece.hasFirework = false;
  currPiece.hasCross = false;
  currPiece.isSpecialPiece = false;
  specialClears[specialClears.length - 1] = Arrays.copyOf(specialClears[specialClears.length - 1], specialClears[specialClears.length - 1].length + 1);
  specialClears[specialClears.length - 1][specialClears[specialClears.length - 1].length - 1] = currPiece;
}

public void shrinkPieces(Piece[] listOfPieces){
  boolean hasShrinked = false;
  for(int i = 0; i < listOfPieces.length; i++){
    listOfPieces[i].shrinkSize += shrinkRate;
    if(listOfPieces[i].shrinkSize >= shrinkLimit){
      listOfPieces[i].pieceID = 0;
      listOfPieces[i].fireworkPos = 0;
      listOfPieces[i].crossPos = 0;
      listOfPieces[i].specialVal = 0;
    }else{
      hasShrinked = true;
    }
  }
  if(!hasShrinked){
    for(int j = 0; j < result.length - 1; j++){
      result[j] = result[j + 1];
    }
    result = Arrays.copyOf(result, result.length - 1);
    if (result.length <= 0){
      needsToClear = false;
      needsToDrop = true;
      clearAllPieces = false;
      dropPieces();
    }
  }
}
public void fillEmptyCellsOutsidePlayField(){
  for(int i = 0; i < colLen; i++){
    for(int j = 0; j < 2; j++){
      board[i][j].currPiece.shrinkSize = 0;
      if(board[i][j].currPiece.pieceID == 0){
        int r = PApplet.parseInt(random(1, 7));
        while(r == prevID){
          r = PApplet.parseInt(random(1, 7));
        }
        board[i][j].currPiece.pieceID = r;
        prevID = r;
      }
    }
  }
}

//calculates the number of spaces within a continuous section of a row 
//(helps with the droppingPieces function to prevent weird behaviour i.e. moving diagonally before straight down)
public int spacesInARow(int col, int row, int[] listOfHoles){
  int res = 0;
  //checks for all pieces in and above the row
  for(int j = row; j >= 2; j--){
    //checks if there is a hole within the contiguous range
    for(int k = 0; k < listOfHoles.length; k++){
      if (j == listOfHoles[k]){
        res++;
      }
    }
    //hits a border
    if(board[col][j].currPiece.pieceID == -1){
      break;
    }
    //hits an empty cell
    if(board[col][j].currPiece.pieceID == 0){
      res++;
    }
  }
  //checks for all pieces in and below the row
  for(int j = row; j < rowLen; j++){
    //checks if there is a hole within the contiguous range
    for(int k = 0; k < listOfHoles.length; k++){
      if (j == listOfHoles[k]){
        res++;
      }
    }
    //hits a border
    if(board[col][j].currPiece.pieceID == -1){
      break;
    }
    //hits an empty cell
    if(board[col][j].currPiece.pieceID == 0){
      res++;
    }
  }
  return res;
}

Cell[] droppingPieces = {}; //stores all the pieces currently dropping
int[][] droppingDisps = {}; //stores all the directions of the dropping pieces
boolean needsToDrop = false; //checks if there are pieces to drop
int dropCounter = 0; //sets the amount of times the dropping loop has to ocurr

public void dropPieces(){
  dropCounter = cellSize / positiveDisp;
  boolean needToKeepLooping = true;
  //an array keeping track of the holes made when making movements (when a piece is moved in a row, a hole is made on that row)
  int[][] holesMade = new int[colLen][];
  for(int i = 0; i < holesMade.length; i++){
    holesMade[i] = new int[0];
  }
  /*  
  drop priority (chooses the first piece available):
  1. right above
  2. diagonally top left***
  3. diagonally top right***
  
  ***: has a condition where the row either to the left or right (depends on which direction it's taking from) 
  MUST be fully filled within the section that is directly next to the current piece it's being taken from 
  (rows separated by borders won't be considered), before allowing pieces to the left or right to take a piece within its column
  
  continuously loop doing the following:
  start from the top left of the board (go column by column). If the current piece is empty and the any 3 above are non-empty (and not going to move due to another empty piece),
  check if the piece is on the zeroth row. If it is, spawn a piece in it. 
  Delete the current piece and move the any of the three pieces above it according to the drop priority. 
  If a piece has moved in a current row, finish checking the current row, then restart from the top left.
  
  If the loop has reached the end and no pieces have moved at all, then break out of the loop.
  */

  //this double for loop gets all of the pieces that need to be moved in one cycle
  for(int i = 0; i < colLen; i++){
    int finalRow = 0;
    //start from the first row of the playfield to prevent a bug where it detects the first row outside the playfield, 
    //causing delays between drops (because the function returns with droppingPieces.length = 0 without it actually reaching the end of the board)
    for(int j = 2; j < rowLen; j++){
      finalRow = j;
      if(board[i][j].currPiece.pieceID != 0 || board[i][j].currPiece.isDropping){ 
        continue;
      }
      //checks if curr piece is an empty piece (not disabled) and isn't dropping
      needToKeepLooping = false; //disables the need to keep looping as a match is found
      for(; j >= 0; j--){ //keeps going up the rows until j = 0
        if(j == 0){
          if(board[i][j].currPiece.pieceID == 0){ //checks if the piece on the top row is empty and not disabled
            int r = PApplet.parseInt(random(1, 7));
            while(r == prevID){
              r = PApplet.parseInt(random(1, 7));
            }
            board[i][0].currPiece = new Piece(i, 0, r);
            prevID = r;
          }
        } else if(board[i][j].currPiece.pieceID != -1){ //checks if the current piece isn't disabled
          boolean foundPiece = false; //condition to check if a piece has been found for dropping
          
          //checks if the piece isn't dropping and isn't disabled
          if(board[i][j - 1].currPiece.pieceID != -1 && !board[i][j - 1].currPiece.isDropping){ 
            println(i, j, "E", spacesInARow(i, j, holesMade[i]));
            //checks if any holes were made in this row (meaning there is room to drop down into)
            if(spacesInARow(i, j, holesMade[i]) > 0){
              //needToKeepLooping = true;
              //appends the row into holesMade according to its column number
              holesMade[i] = Arrays.copyOf(holesMade[i], holesMade[i].length + 1);
              holesMade[i][holesMade[i].length - 1] = j;
              println("HI", i, j);
              //adds the current piece to droppingPieces
              droppingPieces = Arrays.copyOf(droppingPieces, droppingPieces.length + 1);
              droppingPieces[droppingPieces.length - 1] = board[i][j - 1];
              board[i][j - 1].currPiece.isDropping = true;
              
              //adds the direction of the current piece to droppingDisps
              droppingDisps = Arrays.copyOf(droppingDisps, droppingDisps.length + 1);
              droppingDisps[droppingDisps.length - 1] = new int[2];
              droppingDisps[droppingDisps.length - 1][0] = 0;
              droppingDisps[droppingDisps.length - 1][1] = positiveDisp;
              
              foundPiece = true;
            }
          }
          //check if the cell wanting the diagonal piece is within the playfield and hasn't taken a piece from the previous condition
          if(i > 0 && j >= 2 && !foundPiece){
            //checks if the piece isn't dropping and isn't disabled
            if(board[i - 1][j - 1].currPiece.pieceID != -1 && !board[i - 1][j - 1].currPiece.isDropping){ 
              //checks if there are any holes to the right or if the current row is full 
              if(spacesInARow(i - 1, j, holesMade[i - 1]) > 0 || spacesInARow(i, j, holesMade[i]) == 0){ 
                println(i, j, "B", board[i][j].currPiece.pieceID,  board[i][j - 1].currPiece.pieceID);
                needToKeepLooping = true;
              } else{
                println(i, j, "A");
                //appends the row into holesMade according to its column number
                holesMade[i - 1] = Arrays.copyOf(holesMade[i - 1], holesMade[i - 1].length + 1);
                holesMade[i - 1][holesMade[i - 1].length - 1] = j;
                //adds the current piece to droppingPieces
                droppingPieces = Arrays.copyOf(droppingPieces, droppingPieces.length + 1);
                droppingPieces[droppingPieces.length - 1] = board[i - 1][j - 1];
                board[i - 1][j - 1].currPiece.isDropping = true;
                
                //adds the direction of the current piece to droppingDisps
                droppingDisps = Arrays.copyOf(droppingDisps, droppingDisps.length + 1);
                droppingDisps[droppingDisps.length - 1] = new int[2];
                droppingDisps[droppingDisps.length - 1][0] = positiveDisp;
                droppingDisps[droppingDisps.length - 1][1] = positiveDisp;
                
                foundPiece = true;
                i--; //updates the i position so that the next piece checked matches the current match
              }
            }
          }
          //check if the cell wanting the diagonal piece is within the playfield and hasn't taken a piece from the previous two conditions
          if(i < colLen - 1 && j >= 2 && !foundPiece){ 
            //checks if the piece isn't dropping and isn't disabled
            if(board[i + 1][j - 1].currPiece.pieceID != -1 && !board[i + 1][j - 1].currPiece.isDropping){
              //checks if there are any holes to the left or if the current row is full
              if(spacesInARow(i + 1, j, holesMade[i + 1]) > 0 || spacesInARow(i, j, holesMade[i]) == 0){
                println(i, j, "C", spacesInARow(i + 1, j, holesMade[i + 1]), board[i][j].currPiece.pieceID);
                needToKeepLooping = true;
              } else{
                println(i, j, "A", spacesInARow(i + 1, j, holesMade[i + 1]), board[i][j].currPiece.pieceID);
                //appends the row into holesMade according to its column number
                holesMade[i + 1] = Arrays.copyOf(holesMade[i + 1], holesMade[i + 1].length + 1);
                holesMade[i + 1][holesMade[i + 1].length - 1] = j;
                //adds the current piece to droppingPieces
                droppingPieces = Arrays.copyOf(droppingPieces, droppingPieces.length + 1);
                droppingPieces[droppingPieces.length - 1] = board[i + 1][j - 1];
                board[i + 1][j - 1].currPiece.isDropping = true;
                
                //adds the direction of the current piece to droppingDisps
                droppingDisps = Arrays.copyOf(droppingDisps, droppingDisps.length + 1);
                droppingDisps[droppingDisps.length - 1] = new int[2];
                droppingDisps[droppingDisps.length - 1][0] = negativeDisp;
                droppingDisps[droppingDisps.length - 1][1] = positiveDisp;
                
                foundPiece = true;
                i++; //updates the i position so that the next piece checked matches the current match
              }
            }
          }
        }
      }
      break;
    }
    if(!needToKeepLooping){
      break; 
    } else if(i == colLen - 1 && finalRow == rowLen - 1){
      needsToDrop = false;
    }
  }
  for(int i = 0; i < droppingPieces.length; i++){
    println(droppingPieces[i].x, droppingPieces[i].y);
  }
}
public void generateBoardAndPieces(){
  for(int i = 0; i < colLen; i++){
    for(int j = 0; j < rowLen; j++){
      int r = PApplet.parseInt(random(1, 7));
      while(r == prevID){
        r = PApplet.parseInt(random(1, 7));
      }
      board[i][j] = new Cell(i, j, new Piece(i, j, r));
      prevID = r;
      if (j < 2){
        board[i][j].hasPiece = false;
      }
    }
  }
}

public void generateDispsFromCenter(){
  /*
  find the center of the playfield (might not be in a cell) using the colLen / 2 and (2 + rowLen) / 2. 
  make a new 2D array that stores the vertical and horizontal displacements of each piece.
  */
  
  int rows = max(rowLen - 2, 0);
  
  //resizes both arrays to an appropriate size
  cellVertiDispsFromCenter = new int[colLen][rows]; 
  cellHorizDispsFromCenter = new int[colLen][rows]; 
  
  int[] centerXYPos = {xStartPos + PApplet.parseInt(PApplet.parseFloat(cellSize)*(PApplet.parseFloat(colLen) * 0.5f)), yStartPos + PApplet.parseInt(PApplet.parseFloat(cellSize) * (2 + PApplet.parseFloat(rowLen)) * 0.5f)};
  for(int i = 0; i < colLen; i++){
    for(int j = 0; j < rows; j++){
      cellHorizDispsFromCenter[i][j] = centerXYPos[0] - (xStartPos + board[i][j + 2].x * cellSize + cellSize / 2);
      cellVertiDispsFromCenter[i][j] = centerXYPos[1] - (yStartPos + board[i][j + 2].y * cellSize + cellSize / 2);
      //println(i, j);
      //println("X", cellVertiDispsFromCenter[i][j], "Y", cellHorizDispsFromCenter[i][j]);
    }
  }
}

public void generateLevel(int level){
  //note: cellSize must be a multiple of ten to prevent weird behaviour within the rest of the program
  switch(level){
    case 1:
      colLen = 5;
      rowLen = 7;
      cellSize = 100;
      targetScore = 50 * scoreIncrement;
      moveCount = 15;
      break;
    case 2:  
      colLen = 6;
      rowLen = 8;
      cellSize = 90;
      targetScore = 75 * scoreIncrement;
      moveCount = 18;
      break;
    case 3:
      colLen = 5;
      rowLen = 9;
      cellSize = 80;
      targetScore = 85 * scoreIncrement;
      moveCount = 22;
      break;
    case 4:
      colLen = 7;
      rowLen = 9;
      cellSize = 80;
      targetScore = 80 * scoreIncrement;
      moveCount = 20;
      break;
    case 5:
      colLen = 7;
      rowLen = 9;
      cellSize = 80;
      targetScore = 90 * scoreIncrement;
      moveCount = 20;
      break;
    case 6:
      colLen = 7;
      rowLen = 9;
      cellSize = 80;
      targetScore = 75 * scoreIncrement;
      moveCount = 18;
      break;
    case 7:
      colLen = 7;
      rowLen = 12;
      cellSize = 60;
      targetScore = 100 * scoreIncrement;
      moveCount  = 20;
      break;
    case 8:
      colLen = 9;
      rowLen = 13;
      cellSize = 60;
      targetScore = 115 * scoreIncrement;
      moveCount = 23;
      break;
    case 9:
      colLen = 10;
      rowLen = 13;
      cellSize = 60;
      targetScore = 135 * scoreIncrement;
      moveCount = 25;
      break;
    default:
      colLen = rowLen = 0;
      cellSize = 0;
      targetScore = -1;
      moveCount = -1;
      playerScore = -1;
      return;
  }
  //calculates the starting x and y position according to the current board size
  //they both take the center of the playfield as the reference point (700, 350) 
  //then they count the cols and rows needed to shift by
  xStartPos = width * 2/3 - PApplet.parseInt(PApplet.parseFloat(colLen) / 2.0f * cellSize);
  yStartPos = height / 2 - PApplet.parseInt((2 + rowLen) / 2.0f * cellSize);
  shrinkLimit = cellSize * 3 / 10;
  shrinkRate = PApplet.parseFloat(cellSize) / 40;
  positiveDisp = cellSize / 10;
  negativeDisp = -1 * positiveDisp;
  board = new Cell[colLen][rowLen];
  playerScore = 0;
}

public void generateHoles(int level){
  int bottomY = 2;
  switch(level){
    case 2:
      for(int idx = 2; idx <= 3; idx++){
        board[idx][bottomY].disableCell();
        board[idx][rowLen - 1].disableCell();
        board[0][bottomY + idx].disableCell();
        board[colLen - 1][bottomY + idx].disableCell();
      }
      break;
    case 3:
      for(int j = 0; j < rowLen; j++){
        if(j == (bottomY + rowLen) / 2){
          continue;
        }
        board[2][j].disableCell();
      }
      break;
    case 4:
      for(int idx = 2; idx <= 4; idx++){
        board[idx][bottomY].disableCell();
        board[idx][rowLen - 1].disableCell();
        board[0][bottomY + idx].disableCell();
        board[colLen - 1][bottomY + idx].disableCell();
      }
      board[3][bottomY + 1].disableCell();
      board[3][rowLen - 2].disableCell();
      board[1][bottomY + 3].disableCell();
      board[colLen - 2][bottomY + 3].disableCell();
      break;
    case 5:
      int[] cols = {0, colLen/2, colLen - 1};
      for(int idx = 0; idx < cols.length; idx++){
        board[cols[idx]][bottomY].disableCell();
        board[cols[idx]][(bottomY + rowLen)/2].disableCell();
        board[cols[idx]][rowLen - 1].disableCell();
      }
      break;
    case 6:
      for(int idx = 0; idx <= 2; idx++){
        board[idx][bottomY + 2 - idx].disableCell();
        board[colLen - 1 - idx][bottomY + 2 - idx].disableCell();
        board[idx][rowLen - 3 + idx].disableCell();
        board[colLen - 1 - idx][rowLen - 3 + idx].disableCell();
      }
      board[3][(bottomY + rowLen) / 2].disableCell();
      break;
    case 7:
      for(int j = bottomY + 5; j < rowLen; j++){
        board[0][j].disableCell();
        board[colLen - 1][j].disableCell();
        if(j >= bottomY + 7){
          board[1][j].disableCell();
          board[colLen - 2][j].disableCell();
        }
      }
      board[2][rowLen - 1].disableCell();
      board[4][rowLen - 1].disableCell();
      break;
    case 8:
      for(int j = bottomY + 2; j < rowLen - 2; j++){
        board[0][j].disableCell();
        board[colLen - 1][j].disableCell();
        if(j >= bottomY + 3 && j < rowLen - 3){
          board[1][j].disableCell();
          board[colLen - 2][j].disableCell();
        }
        if(j >= bottomY + 4 && j < rowLen - 4){
          board[2][j].disableCell();
          board[colLen - 3][j].disableCell();
        }
        if(j >= bottomY + 5 && j < rowLen - 5){
          board[3][j].disableCell();
          board[colLen - 4][j].disableCell();
        }
      }
      break;
    case 9:
      for(int i = 0; i < colLen; i++){
        if(i < 4 || i > colLen - 5){
          board[i][bottomY].disableCell();
          board[i][bottomY + 4].disableCell();
          board[i][rowLen - 1].disableCell();
          board[i][rowLen - 2].disableCell();
        }
        if(i < 3 || i > colLen - 4){
          board[i][bottomY + 1].disableCell();
          board[i][bottomY + 5].disableCell();
          
        }
        if(i < 2 || i > colLen - 3){
          board[i][bottomY + 2].disableCell();
          board[i][bottomY + 6].disableCell();
        }
        if(i < 1 || i > colLen - 2){
          board[i][bottomY + 3].disableCell();
          board[i][bottomY + 7].disableCell();
        }
      }
      break;
    default:
  }
}
public Piece[][] checkSwappedPieces(){
  //case where two special piece have been swapped
  if(board[currX1][currY1].currPiece.isSpecialPiece && board[currX2][currY2].currPiece.isSpecialPiece){
    Piece[] res = {};
    for(int i = 0; i < colLen; i++){
      for(int j = 2; j < rowLen; j++){
        if(board[i][j].currPiece.pieceID > 0){
          board[i][j].currPiece.specialVal = 1;
          res = Arrays.copyOf(res, res.length + 1);
          res[res.length - 1] = board[i][j].currPiece;
        }
      }
    }
    playerScore += 1000;
    addScores(res.length - 2, 0, 0, 2);
    result = Arrays.copyOf(result, result.length + 1);
    result[result.length - 1] = res;
    return result;
  }
  //case where a special piece has been swapped with
  if(board[currX1][currY1].currPiece.isSpecialPiece || board[currX2][currY2].currPiece.isSpecialPiece){
    Piece[][] ret = {{board[currX1][currY1].currPiece, board[currX2][currY2].currPiece}};
    return ret;
  }
  
  //case where two modified pieces of any type have been swapped
  if(board[currX1][currY1].currPiece.isModifiedPiece() && board[currX2][currY2].currPiece.isModifiedPiece()){
    Piece[][] ret = {{board[currX1][currY1].currPiece, board[currX2][currY2].currPiece}};
    return ret;
  }
  
  Piece[][] vertiMatches = {};
  Piece[][] horizMatches = {};
  //checks for horizontal and vertical matches for both pieces
  for(int i = 0; i < 4; i++){
    Piece[] matches = {};
    int[][] visited = {};
    switch(i){
      case 0:
        matches = checkPiece(currX1, currY1, board[currX1][currY1].currPiece.pieceID, "HORIZONTAL", matches, visited);
        break;
      case 1:
        matches = checkPiece(currX1, currY1, board[currX1][currY1].currPiece.pieceID, "VERTICAL", matches, visited);
        break;
      case 2:
        matches = checkPiece(currX2, currY2, board[currX2][currY2].currPiece.pieceID, "HORIZONTAL", matches, visited);
        break;
      case 3:
        matches = checkPiece(currX2, currY2, board[currX2][currY2].currPiece.pieceID, "VERTICAL", matches, visited);
        break;
    }
    if (matches.length >= 3){
      boolean isIncluded = false;
      if(i % 2 == 1){ //Vertical matches
        for(int idx = 0; idx < vertiMatches.length; idx++){ //removes duplicate vertical values
          if (vertiMatches[idx][0].pieceID == matches[0].pieceID && vertiMatches[idx][0].x == matches[0].x){
            isIncluded = true;
            break;
          }
        }
        if(!isIncluded){
          vertiMatches = Arrays.copyOf(vertiMatches, vertiMatches.length + 1);
          vertiMatches[vertiMatches.length - 1] = matches;
        }
      } else{ //Horizontal matches
        for(int idx = 0; idx < horizMatches.length; idx++){ //removes duplicate horizontal values
          if (horizMatches[idx][0].pieceID == matches[0].pieceID && horizMatches[idx][0].y == matches[0].y){
            isIncluded = true;
            break;
          }
        }
        if(!isIncluded){
          horizMatches = Arrays.copyOf(horizMatches, horizMatches.length + 1);
          horizMatches[horizMatches.length - 1] = matches;
        }
      }
    }
    if(horizMatches.length > 0 && vertiMatches.length > 0){ //checks if both arrays are non-empty
      for(int k = 0; k < horizMatches[horizMatches.length - 1].length; k++){
        boolean foundIntersect = false;
        for(int l = 0; l < vertiMatches[vertiMatches.length - 1].length; l++){
          if(horizMatches[horizMatches.length - 1][k] == vertiMatches[vertiMatches.length - 1][l]){ //Checks if a piece has made both a vertical and horizontal match
            foundIntersect = true;
            for(int idx = 1; idx < vertiMatches[vertiMatches.length - 1].length; idx++){ //appends the vertical result to the horizontal array
              horizMatches[horizMatches.length - 1] = Arrays.copyOf(horizMatches[horizMatches.length - 1], horizMatches[horizMatches.length - 1].length + 1);
              horizMatches[horizMatches.length - 1][horizMatches[horizMatches.length - 1].length - 1] = vertiMatches[vertiMatches.length - 1][idx];
            }
          }
        }
        if(foundIntersect){
          //deletes the record from vertiMatches to preven duplicate entries in result (important for checkSpecialMatches function to work)
          vertiMatches = Arrays.copyOf(vertiMatches, vertiMatches.length - 1);
          break;
        }
      }
    }
  }
  //println("V: ", vertiMatches.length, "H: ", horizMatches.length);
  Piece[][] ret = {}; //combines both vertical and horizontal matches into one array
  for(int i = 0; i < vertiMatches.length; i++){
    ret = Arrays.copyOf(ret, ret.length + 1);
    ret[ret.length - 1] = vertiMatches[i];
  }
  for(int i = 0; i < horizMatches.length; i++){
    ret = Arrays.copyOf(ret, ret.length + 1);
    ret[ret.length - 1] = horizMatches[i];
  }
  return ret;
}

int swapCounter = 0; //counts how many times the pieces have to move during the swapping animation

public void switchPieces(Piece piece1, Piece piece2){
  //piece1 is the first piece selected, piece2 is the second piece selected
  swapCounter = cellSize / positiveDisp; //positiveDisp should be a factor of cellSize for smooth movement 
  //(otherwise it becomes jittery)
  int xDisp = piece1.x - piece2.x;
  int yDisp = piece1.y - piece2.y;
  
  switch(xDisp){
    case 1: //Case where first piece is to the right of the second piece
      piece1Disp[0] = negativeDisp;
      piece2Disp[0] = positiveDisp;
      return;
    case -1: //Case where first piece is to the left of the second piece
      piece1Disp[0] = positiveDisp;
      piece2Disp[0] = negativeDisp;
      return;
    default:
  }
  
  switch(yDisp){
    case 1: //Case where first piece is below the second piece
      piece1Disp[1] = negativeDisp;
      piece2Disp[1] = positiveDisp;
      return;
    case -1: //Case where first piece is above the second piece
      piece1Disp[1] = positiveDisp;
      piece2Disp[1] = negativeDisp;
      return;
    default:
  }
}


  public void settings() { size(1050, 700); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Match_3_game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
